########################################################################################
# Workshop: Coding for PDEs with Neural Networks
# Date: 2025-24-01
# Author: Danilo Aballay, Vicente Iligaray, Ignacio Tapia y Manuel SÃ¡nchez
########################################################################################

values_phi0_ = jnp.array([[0.9083804012656871,  0.7331497981296533,  0.47654496148466596, 0.21994012483967862, 0.04470952170364481],
                         [0.7331497981296533,  0.591721954534264, 0.38461732752642075, 0.17751270051857745,  0.036084856923188136],
                         [0.47654496148466596, 0.38461732752642075, 0.25,       0.11538267247357925, 0.02345503851533401],
                         [0.21994012483967862, 0.17751270051857745,  0.11538267247357925, 0.053252644428581054, 0.010825220107479883],
                         [0.04470952170364481, 0.036084856923188136, 0.02345503851533401, 0.010825220107479883, 0.002200555327023207]])
values_phi1_ = jnp.array([[0.04470952170364481, 0.036084856923188136, 0.02345503851533401, 0.010825220107479883, 0.002200555327023207],
                         [0.21994012483967862,  0.17751270051857745, 0.11538267247357925, 0.053252644428581054,  0.010825220107479883],
                         [0.47654496148466596, 0.38461732752642075, 0.25,       0.11538267247357925, 0.02345503851533401],
                         [0.7331497981296533, 0.591721954534264,  0.38461732752642075, 0.17751270051857745, 0.036084856923188136],
                         [0.9083804012656871, 0.7331497981296533, 0.47654496148466596, 0.21994012483967862, 0.04470952170364481]])
values_phi2_ = jnp.array([[0.002200555327023207, 0.010825220107479883, 0.02345503851533401, 0.036084856923188136, 0.04470952170364481],
                         [0.010825220107479883,  0.053252644428581054, 0.11538267247357925, 0.17751270051857745,  0.21994012483967862],
                         [0.02345503851533401, 0.11538267247357925, 0.25,       0.38461732752642075, 0.47654496148466596],
                         [0.036084856923188136, 0.17751270051857745,  0.38461732752642075, 0.591721954534264, 0.7331497981296533],
                         [0.04470952170364481, 0.21994012483967862, 0.47654496148466596, 0.7331497981296533, 0.9083804012656871]])
values_phi3_ = jnp.array([[0.04470952170364481, 0.21994012483967862, 0.47654496148466596, 0.7331497981296533, 0.9083804012656871],
                         [0.036084856923188136,  0.17751270051857745, 0.38461732752642075, 0.591721954534264,  0.7331497981296533],
                         [0.02345503851533401, 0.11538267247357925, 0.25,       0.38461732752642075, 0.47654496148466596],
                         [0.010825220107479883, 0.053252644428581054,  0.11538267247357925, 0.17751270051857745, 0.21994012483967862],
                         [0.002200555327023207, 0.010825220107479883, 0.02345503851533401, 0.036084856923188136, 0.04470952170364481]])



def load_vector(coords, elements):
    problem_test = problem(problem_number)
    f = problem_test.f
    aux1 = 2*jnp.sqrt(10/7)
    aux2 = 13*jnp.sqrt(70)
    nodes = jnp.array([-1/3*jnp.sqrt(5+aux1), -1/3*jnp.sqrt(5-aux1), 0, 1/3*jnp.sqrt(5-aux1), 1/3*jnp.sqrt(5+aux1)])
    weights = jnp.array([(322-aux2)/900, (322+aux2)/900, 128/225, (322+aux2)/900, (322-aux2)/900])


    def compute_element(e):
        x1, y1 = coords[elements[e, 0], :]
        x2, y2 = coords[elements[e, 2], :]
        hx, hy = x2 - x1, y2 - y1
        transf_nodes_x = 0.5 * hx * nodes + 0.5 * (x1 + x2)
        transf_nodes_y = 0.5 * hy * nodes + 0.5 * (y1 + y2)

        # Compute sums using broadcasting
        tx, ty = jnp.meshgrid(transf_nodes_x, transf_nodes_y, indexing="ij")
        wx, wy = jnp.meshgrid(weights, weights, indexing="ij")
        jacobian = hx * hy * 0.25

        f_vals = f(tx, ty)
        sum0 = jnp.sum(f_vals * values_phi0_ * wx * wy * jacobian)
        sum1 = jnp.sum(f_vals * values_phi1_ * wx * wy * jacobian)
        sum2 = jnp.sum(f_vals * values_phi2_ * wx * wy * jacobian)
        sum3 = jnp.sum(f_vals * values_phi3_ * wx * wy * jacobian)

        return elements[e, :], jnp.array([sum0, sum2, sum3, sum1])

    F = jnp.zeros((coords.shape[0]))
    n_el = elements.shape[0]
    element_indices, element_contributions = jax.vmap(compute_element)(jnp.arange(n_el))
    F = F.at[element_indices].add(element_contributions)

    return F

